/**
 * @file radix_sort.cpp
 * @author Taylor Curran
 * @brief Implementations of counting sort for unsigned integers,
 * a more general counting sort algorithm based on any integer key,
 * and a radix sort that uses this more general counting sort
 * @version 0.1
 * @date 2020-06-29
 * 
 * @copyright Copyright (c) 2020
 * 
 */

#include <cmath>        // std::pow
#include <vector>       // std::vector
#include <cassert>      // assert
#include <iostream>     // std::cout, std::endl
#include <utility>      // std::move
#include <algorithm>    // std::max
#include <functional>   // std::function

/**
 * @brief Implementation for counting sort for vectors
 * of unsigned integers
 */
void counting_sort(std::vector<unsigned>& input)
{
    // No sorting needed is list has less than two elements
    if(input.size() < 2) return;
    
    // Find max values
    unsigned max = *std::max_element(input.begin(), input.end());

    // Create count vector
    std::vector<unsigned> count(max + 1, 0);

    for(auto it = input.begin(); it != input.end(); ++it)
        count[*it]++;

    // Turn into cumulative vector
    for(size_t i = 0; i < count.size() - 1; i++)
        count[i + 1] += count[i];

    // Fill output array
    std::vector<unsigned> output(input.size(), 0);

    /**
     * @note: Why does this iterate from front to back?
     * Because doing so ensures that the algorithm is _stable_
     */
    for(int j = input.size() - 1; j >= 0; j--)
    {
        // Insert value into output
        output[count[input[j]] - 1] = input[j];

        // Decrement count
        count[input[j]]--;
    }

    // Transfer value to input array
    std::move(output.begin(), output.end(), input.begin());
}

/**
 * @brief Generalization of the counting sort implementation
 * above that sorts the values in \p input using the keys 
 * generated by the \p key function
 */
template<class T>
void counting_sort(std::vector<T>& input, std::function<int (T)> key)
{
    if(input.size() < 2)
        return;

    // Find extreme values
    int min = INT_MAX;
    int max = INT_MIN;

    int k;
    for(auto it = input.begin(); it != input.end(); ++it)
    {
        k = key(*it);
        
        if(k> max) 
            max = k;

        if(k < min) 
            min = k;
    }

    // Create count vector
    std::vector<unsigned> count((max - min) + 1, 0);

    for(auto it = input.begin(); it != input.end(); ++it)
        count[key(*it) - min]++;

    // Turn into cumulative count
    for(size_t i = 0; i < (max - min); i++)
        count[i + 1] += count[i];

    // Populate output array
    std::vector<T> output(input.size(), 0);

    for(int j = input.size() - 1; j >= 0; j--)
    {
        output[count[key(input[j]) - min] - 1] = input[j];
        count[key(input[j]) - min]--;
    }

    // Move output to input
    std::move(output.begin(), output.end(), input.begin());
}

/**
 * @brief Sorts \p input using using radix sort by decimal digit
 */
void decimal_radix_sort(std::vector<int>& input)
{
    if(input.size() < 2)
        return;
    
    // Find extreme values
    int max = *std::max_element(input.begin(), input.end());
    int min = *std::min_element(input.begin(), input.end());


    // Perform count sort over digits
    int digit = 0;
    while(
        std::abs(max) / std::pow(10, digit) > 0 && 
        std::abs(min) / std::pow(10, digit) > 0)
    {
        std::function<int(int)> extract_digit = [digit] (int a)
        {
            return (a / (int) std::pow(10, digit)) % 10; 
        };

        counting_sort(input, extract_digit);

        ++digit;
    }
}

/**
 * @brief Sorts \p input using radix sort by binary digit
 * 
 * @note last 
 * 
 * @return int 
 */

int main()
{
    // Test counting sort for unsigned integers ======

    std::cout << std::endl << "Testing specific counting_sort..." << std:: endl;

    std::vector<unsigned> v;                     // [] -> []
    counting_sort(v);
    assert(v == std::vector<unsigned>());

    v = {1};                                // [1] -> [1]
    counting_sort(v);
    assert(v == std::vector<unsigned>({1}));

    v = {2,1};                              // [2,1] -> [1,2]
    counting_sort(v);
    assert(v == std::vector<unsigned>({1,2}));

     v = {1,2,3};                           // [1,2,3] -> [1,2,3]
    counting_sort(v);
    assert(v == std::vector<unsigned>({1,2,3}));

    v = {1,3,2};                           // [1,3,2] -> [1,2,3]
    counting_sort(v);
    assert(v == std::vector<unsigned>({1,2,3}));

    v = {3,1,2};                            // [3,1,2] -> [1,2,3]
    counting_sort(v);
    assert(v == std::vector<unsigned>({1,2,3}));

    v = {1,5,4,2,3};                      // [1,5,4,2,3] -> [1,2,3,4,5]
    counting_sort(v);
    assert(v == std::vector<unsigned>({1,2,3,4,5}));

    std::cout << "All tests passing!" << std::endl << std::endl;

    // Test general counting sort algorithm =====
    // (Sort based on least significant decimal digit)

    std::cout << "Testing general counting_sort..." << std::endl;

    std::function<int(int)> least_significant = [](int a) 
    { 
        return a % 10; 
    };

    std::vector<int> w = {};                                 // [] -> []
    counting_sort(w, least_significant);
    assert(w == std::vector<int>());

    w = {1};                                // [1] -> [1]
    counting_sort(w, least_significant);
    assert(w == std::vector<int>({1}));

    w = {2,1};                              // [2,1] -> [1,2]
    counting_sort(w, least_significant);
    assert(w == std::vector<int>({1,2}));

    w = {1,12,3};                          // [1,12,3] -> [1,12,3]
    counting_sort(w, least_significant);
    assert(w == std::vector<int>({1,12,3}));

    w = {-321,3,2};                         // [-321,3,2] -> [-321,2,3]
    counting_sort(w, least_significant);
    assert(w == std::vector<int>({-321,2,3}));

    w = {3,-11,22};                         // [3,-11,22] -> [-11,22,3]
    counting_sort(w, least_significant);
    assert(w == std::vector<int>({-11,22,3}));

    w = {10,543,-422,-2,37};                // [10,543,-422,-2,37] -> [-422,-2,10,543,37]
    counting_sort(w, least_significant);
    assert(w == std::vector<int>({-422,-2,10,543,37}));

    std::cout << "All tests passsing!" << std::endl << std::endl;

    // Test decimal radix sort =====

    std::cout << "Testing decimal radix_sort..." << std::endl;

    w = {};                                 // [] -> []
    decimal_radix_sort(w);
    assert(w == std::vector<int>());

    w = {1};                                // [1] -> [1]
    decimal_radix_sort(w);
    assert(w == std::vector<int>({1}));

    w = {2,1};                              // [2,1] -> [1,2]
    decimal_radix_sort(w);
    assert(w == std::vector<int>({1,2}));

    w = {1,12,3};                          // [1,12,3] -> [1,3,12]
    decimal_radix_sort(w);
    assert(w == std::vector<int>({1,3,12}));

    w = {-321,3,2};                         // [-321,3,2] -> [-321,2,3]
    decimal_radix_sort(w);
    assert(w == std::vector<int>({-321,2,3}));

    w = {3,-11,22};                         // [3,-11,22] -> [-11,3,22]
    decimal_radix_sort(w);
    assert(w == std::vector<int>({-11,3,22}));

    w = {10,543,-422,-2,37};                // [10,543,-422,-2,37] -> [-422,-2,10,37,543]
    decimal_radix_sort(w);
    assert(w == std::vector<int>({-422,-2,10,37,543}));

    std::cout << "All tests passsing!" << std::endl << std::endl;
    exit(0); 
}